from dataclasses import dataclass

import math

import matplotlib.pyplot as plot


@dataclass
class Entry:
    """
    Dataclass that represents an entry of the csv file.
    """

    age: int
    sex: str
    tension: int
    cholestrol: int
    bpm: int
    has_desease: bool

    @classmethod
    def from_csv_entry(cls, entry: list[str]) -> 'Entry':
        """
        Builds an Entry from a list of strings generated by the csv built-in module.

        :param entry: Entry as a list of strings.
        :return: The class Entry generated from entry.
        """
        return cls(
            int(entry[0]),
            entry[1],
            int(entry[2]),
            int(entry[3]),
            int(entry[4]),
            bool(int(entry[5]))
        )


class Storage:
    """
    Class that stores and organizes data from the csv file.
    """

    def __init__(self):
        """
        Class constructor.
        """

        self.age_ranges = 5  # Ranges to group the ages.
        self.max_age: int = 0  # The highest value for the age field.
        self.total_entries: int = 0  # The total of entries stored.

        # Dictionary containing entries organized by sickness, sex and age.
        self.__items = {
            "sick": {
                "M": {},
                "F": {}
            },

            "not_sick": {
                "M": {},
                "F": {}
            }
        }

    def __get_group__(self, age: int) -> int:
        """
        Returns the interval of which the provided age bellongs to, the interval is defined by age_ranges.

        Example:
            $> __get_group__(13)
            $> 10

        :param age: The age to retrieve the group from.
        :return: The group as integer.
        """
        return math.floor(age / self.age_ranges) * self.age_ranges

    def __get_missing_ranges__(self, latest_group: int, current_group: int) -> list[int]:
        """
        Generate a list with the intervals needed to be created on the database.

        Example:
            $> __get_missing_ranges__(5, 40)
            $> [10, 15, 20, 25, 30, 35, 40]

        :param latest_group: Lowest bound.
        :param current_group: Highest bound.
        :return: List with the intervals needed to be created.
        """
        return list(range(latest_group + self.age_ranges, current_group + self.age_ranges, self.age_ranges))

    def add_entry(self, entry: Entry) -> None:
        """
        Add an entry to the database, according to the 'model' (__items).
        :param entry: The entry to be added of type Entry.
        :return: None
        """

        # Match sickness status to the boolean value on the entry.
        entry_status: str = "not_sick"
        if entry.has_desease:
            entry_status = "sick"

        # Age interval for the age of the given entry.
        current_group: int = self.__get_group__(entry.age)

        # If the new added age is greater than the old one we need to update the age intervals on the data model.
        if current_group > self.max_age:

            # Age interval for the old, current age.
            latest_group: int = self.__get_group__(self.max_age)

            # Check wether the new age is within the same interval as the old one (ex. 45, 46).
            if current_group > latest_group:

                # A list with the intervals needed to be created.
                missing_ranges: list[int] = self.__get_missing_ranges__(latest_group, current_group)

                # Create the intervals for each category.
                for r in missing_ranges:
                    self.__items["sick"]["M"].update({r: []})
                    self.__items["sick"]["F"].update({r: []})
                    self.__items["not_sick"]["F"].update({r: []})
                    self.__items["not_sick"]["M"].update({r: []})

            self.max_age = entry.age  # Update the new age to the current age (max_age).

        # Add the entry to the database.
        self.__items[entry_status][entry.sex][current_group].append(entry)
        self.total_entries += 1  # Update the total entry counter.

    def dist_sick_by_gender(self, display: bool = False) -> dict:
        """
        Obtain a distribution for the number of sick people by their gender.
        :return: A dictionary containing the values, has keys "M" and "F".
        """

        # Number of sick males.
        sick_males: int = sum([len(self.__items["sick"]["M"][q]) for q in self.__items["sick"]["M"]])

        # Number of sick females.
        sick_females: int = sum([len(self.__items["sick"]["F"][q]) for q in self.__items["sick"]["F"]])

        if display:
            # Plotting the results onto a bar graph.
            plot.bar(["Male", "Female"], [sick_males, sick_females])
            plot.xlabel("Gender")
            plot.ylabel("# Sick People")
            plot.title("Distribution of sick people by gender.")
            plot.show()

        return {
            'M': sick_males,
            'F': sick_females
        }

    def dist_sick_by_age(self, display: bool = False) -> dict:

        males: dict = self.__items["sick"]["M"]  # Dictionary of sick males.
        females: dict = self.__items["sick"]["F"]  # Dictionary of sick females.

        # Age intervals as a list.
        keys: list[int] = list(males.keys())

        values_male: list[int] = [len(males[k]) for k in keys]  # Number of sick males per age interval.
        values_female: list[int] = [len(females[k]) for k in keys]  # Number of sick females per age interval.

        total_values: list[int] = [x + y for x, y in zip(values_male, values_female)]  # Total number of sick people per age interval.

        if display:
            # Plotting the results onto a bar graph.
            plot.bar(keys, total_values)
            plot.xlabel("Age Intervals")
            plot.ylabel("# Sick People")
            plot.title("Distribution of sick people by age intervals.")
            plot.show()

        return dict(zip(keys, total_values))

